[{"title":"解决Debina系统自动更新软件包的问题","url":"/archives/2/","content":"\n　　不知从何时开始，我的电脑每天开机连接上网络之后，不断的在下载数据，状态栏显示网速达到每秒1到2兆。开始我还不太在意，不过后来由于带宽全部被这种莫名其奥妙的下载占据了，我连网页都无否正常浏览了，所以我决定解决掉这个问题。下面记录一下解决这个问题的过程。\n\n　　首先我利用一款名为`nethogs`的实时网速监控程序查看是哪个进程在占据带宽，发现占据带宽的正是系统的APT包管理工具，我想肯定是系统在执行自动更新。杀掉这个进程后，我便去Google了一下如何关闭APT包管理工具的的自动更新。网上人们提供的解决方案大都一致：修改APT的配置文件。\n\nAPT关于自动更新的配置文件位于\"/etc/apt/apt.conf.d/20auto-upgrades\", 将其中的\n```shell\nAPT::Periodic::Update-Package-Lists \"1\";\nAPT::Periodic::Unattended-Upgrade \"1\";\n```\n更改为\n```shell\nAPT::Periodic::Update-Package-Lists \"0\";\nAPT::Periodic::Unattended-Upgrade \"0\";\n```\n其中\n- APT::Periodic::Update-Package-Lists; 每一天自动运行一次 apt-get update，1 表示启用，0 表示禁用。\n- APT::Periodic::Unattended-Upgrade; 每一天运行一次 unattended-upgrade 安全升级脚本，1 表示启用，0 表示禁用。\n  \n　　然而，并无卵用，第二天开机后APT又执行自动更新了，更奇怪的是杀掉APT进程不久之后它会再一次运行。这时我才意识到一件事情，APT是不会自动把自己调入内存运行的，一定是另有进程调用了它。打开进程管理器之后，查看 APT 进程的依赖关系，发现果然它有一个名为 `packagekit` 的父进程，我查了一下 `packagekit` 是一个旨在简化Linux发行版安装和更新软件的系统，它为不同的包管理工具提供了统一的前端，你可以在不同的Linux发行版中使用它来管理软件包。\n\n　　我的系统默认在开机时启动packgekit服务，查看 `packagekit` 的启动单元: \n`cat /lib/systemd/system/packagekit.service`\n```shell\n[Unit]\nDescription=PackageKit Daemon\n# PK does not know how to do anything on ostree-managed systems;\n# currently the design is to have dedicated daemons like\n# eos-updater and rpm-ostree, and gnome-software talks to those.\nConditionPathExists=!/run/ostree-booted\n\n[Service]\nType=dbus\nBusName=org.freedesktop.PackageKit\nUser=root\nExecStart=/usr/lib/packagekit/packagekitd\n```\n*系统每次开机时都会启动这个单元，执行 `/usr/lib/packagekit/packagekitd` 命令，而 `packagekit` 又将在运行期间调起APT下载需要更新的软件包。*\n\n　　知道了这些问题自然也就解决了，禁用此服务: `systemctl disable packagekit.service`.\n　　或者干脆删除 `/lib/systemd/system/` 目录下的 `packagekit.service` (当然你也可以把这个文件移动到别的地方去，以后用到时再放回来)\n\n　　在那之后，系统便再也没有执行过自动更新了。\n　　\n[附]\n>[nethohs](https://github.com/raboof/nethogs)是一个能按进程实时监控网络的命令行工具，它可以动态的展示某一时刻正在进行通信的进程的网络流量信息。\n\n在 Debian/Ubuntu 下，使用`apt-get install nethogs` 安装它。\n或编译安装:\n```shell\nwget -c https://github.com/raboof/nethogs/archive/v0.8.5.tar.gz\ntar xf v0.8.5.tar.gz \ncd ./nethogs-0.8.5/\nmake && make install\n```\n如果编译失败需要安装依赖库\n```\napt-get install libncurses5-dev libpcap-dev\n```\n\n使用\n\n```shell\nroot@zsimline$ nethogs\nNetHogs version 0.8.5-2+b1\nPID  USER    PROGRAM                   DEV  SENT      RECEIVED  \n2181 mxsyx  /usr/share/code/code       usb0 0.449   0.900 KB/sec\n1598 mxsyx  /usr/lib/chromium/chromium usb0 0.031   0.018 KB/sec\n?    root   unknown TCP                     0.000   0.000 KB/sec\n\n  TOTAL                                     0.480       0.917 KB/se\n```\n\n指定网卡\n```shell\nroot@zsimline$ nethogs wlan0 # 监听wlan0\nroot@zsimline$ nethogs -a    # 监听所有网卡\n```\n\n指定刷新频率 -d seconds (默认为1)\n```shell\nroot@zsimline$ nethogs -d 2\n```\n\n指定刷新次数 -c number (默认不限)\n```shell\nroot@zsimline$ nethogs -c 10\n```\n\n交互模式\n在进入 nethogs 之后，可以使用如下的交互命令:\n```shell\nq: 退出\ns: 按照发送流量排序\nr: 按照流量排序\nm: 修改网速单位 (KB, B, MB) and KB/s\n```","tags":["Linux"],"categories":["Linux"]},{"title":"C++ 标准线程库","url":"/archives/1/","content":"\n　　C++11 引入了对多线程语言级别的支持，<thread> 库是C++的标准线程库，它定义了与编写多线程程序相关的类。 相比于传统的POSIX线程标准，<thread> 库更符合C++的编程风格。\n\n　　<thread> 库是跨平台的，这意味着你可以在任意平台上不经修改直接编译同一段多线程代码（前提是你没有在这段代码中调用其它系统相关的API）\n\n### 创建一个线程\n\nstd::thread 类用来创建一个线程\n\n```cpp\n// dev01.cc\n#include <iostream>\n#include <thread>  // 引入线程库头文件\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n\n  // 等待线程 trd 结束\n  trd.join();\n\n  return 0;\n}\n```\n```shell\n编译dev01.cc （需要动态链接pthread库）\ng++ -o dev dev.cc -lpthread && ./dev\n输出：index 的值为 1\n```\n　　std::thread 的初始化构造函数原型为`template <class Fn, class... Args>`, 构造函数的第一个参数为线程要执行的函数，后面是要传递给线程函数的实参。**值得注意的是，线程在thread类实例化之后就开始执行了，不需要显式的调用任何启动线程的函数。**\n\n　　线程启动后，需要在主线程内调用线程对象的 join 函数。join 函数用于阻塞主线程的执行，当新创建的线程执行完成后，主线程继续执行。一个进程内的所有线程共享某些资源，若不调用线程对象的join 函数，一旦主线程执行结束，操作系统将回收这些资源，新创建的线程得不到这些应有的资源就会终止执行并抛出错误。\n\n【拷贝构造函数】\n std::thread 类不支持拷贝构造 `thread (const thread&) = delete;`\n\n【移动构造函数】\nstd::thread 类支持移动构造函数 `thread (thread&& x) noexcept;`\n```cpp\n// dev02.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n  // 移动动构造一个线程对象\n  // 该操作不会以任何方式影响被移动线程的执行\n  std::thread trd1(std::move(trd));\n\n  // 此时trd对象不再代表任何执行线程\n  // trd.join();\n  trd1.join();\n\n  return 0;\n}\n```\n【赋值操作符】\n 可以使用赋值操作符移动赋值线程对象`thread& operator= (thread&& rhs) noexcept;`\n 不可以使赋值操作符拷贝赋值线程对象`thread& operator= (const thread&) = delete;`\n```cpp\n// dev03.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 创建线程对象数组\n  // 调用类的默认构造函数\n  std::thread trds[3];\n\n  // 使用赋值操作符移动赋值\n  // 该操作不会以任何方式影响被移动线程的执行\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  // 等待线程结束\n  for(int i = 0; i < 3; i++)\n    trds[i].join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n我是线程 2\n我是线程 3\n我是线程 1\n```\n可以看到，线程的执行顺序是不确定的，这取决于操作系统如何调度线程的执行。\n而且，输出也并不总是这样顺眼，比如下面的输出：\n```shell\n我是线程 我是线程 21我是线程 3\n```\nDisplay 函数中的输出语句是可中断的，当某个线程输出 “我是线程 ” 后，它完全有可能被操作系统挂起，等待一段时间后系统再次启动这个线程，输出剩余的内容。\n\n### 获取线程ID\n\n每个线程都有一个唯一标识，通过调用线程对象的 get_id 函数可以得到这个唯一标识。\n\n```cpp\n// dev04.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  std::thread trds[3];\n\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  for(int i = 0; i < 3; i++) {\n    // 线程ID 的类型为 std::thread::id\n    std::thread::id tid = trds[i].get_id();\n    std::cout << \"线程\" << i + 1 << \" \" << tid << std::endl;\n    trds[i].join();\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程1 140121399854848\n线程2 140121391462144\n线程3 140121383069440\n```\n\n### 检测线程可连接性\n\n通过调用线程对象的 joinable 函数可以检测线程对象是否是可连接的。\n如果线程对象表示执行线程，则该对象是可连接的。\n在以下任何情况下，线程对象均不可连接：\n1.  线程对象是由默认构造函数生成的\n2. 线程对象已经被移动（通过移动构造函数或赋值操作符）\n3. 已经调用过线程对象的 join 或 detach 函数\n\n```cpp\n// dev05.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 默认构造 trd1\n  std::thread trd1;\n  // 正常构造 trd2\n  std::thread trd2(Display, 1);\n  // 移动构造 trd3\n  std::thread trd3(std::move(trd2));\n\n  if(trd1.joinable()) {\n    std::cout << \"线程对象trd1可连接\" << std::endl;\n    trd1.join();\n  } else {\n    std::cout << \"线程对象trd1不可连接，它是默认构造的\" << std::endl;\n  }\n  \n  if(trd2.joinable()) {\n    std::cout << \"线程对象trd2可连接\" << std::endl;\n    trd2.join();\n  } else {\n    std::cout << \"线程对象trd2不可连接，它已经被移动了\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3不可连接\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3现在不可连接了\" << std::endl;\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程对象trd1不可连接，它是默认构造的\n线程对象trd2不可连接，它已经被移动了\n线程对象trd3可连接\n线程对象trd3现在不可连接了\n```\n\n### 分离线程\n\n调用线程对象的detach函数可以使新创建的线程与主线程分离，与join函数不同的是，detach函数不会阻塞主线程的执行，若主线程早于新线程执行完毕，新线程将终止执行，不会抛出任何错误。\n\n```cpp\n// dev06.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nvoid DelayThread(int s) {\n  // sleep_for函数使线程睡眠s秒\n  std::this_thread::sleep_for(std::chrono::seconds(s));\n  std::cout << s << \"秒过去了\" << std::endl;\n}\n\nint main() {\n  std::thread trd1(DelayThread, 2);\n  std::thread trd2(DelayThread, 8);\n\n  // 分离线程\n  trd1.detach();\n  trd2.detach();\n\n  // 主线程睡眠5s\n  DelayThread(5);\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n2秒过去了\n5秒过去了\n```\n\n### 交换线程\n\n通过调用线程对象的swap函数可以交换两个线程\n\n```cpp\n// dev07.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  // ...\n}\n\nint main() {\n  std::thread trd1(Display, 2);\n  std::thread trd2(Display, 8);\n\n  std::cout << \"交换前：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  // 交换两个线程\n  trd1.swap(trd2);\n  // 同样可以调用非成员函数交换两个线程\n  // swap(trd1, trd2);\n\n  std::cout << \"交换后：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n交换前：\ntrd1 ID: 140593231992576\ntrd2 ID: 140593223599872\n交换后：\ntrd1 ID: 140593223599872\ntrd2 ID: 140593231992576\n```\n\n### 获取硬件并发数量\n\n有时我们想知道处理器支持的硬件并发数量，可以调用线程类的静态函数 hardware_concurrency 来获取这个值，该函数返回值是一个无符号整数。\n\n```cpp\n// dev08.cc\n#include <iostream>\n#include <thread>\n\nint main() {\n  std::cout << std::thread::hardware_concurrency();\n  return 0;\n}\n```\n```shell\n编译上面的程序输出（在我的四核心处理器上）\n4\n编译上面的程序输出（在我的单核心处理器上）\n1\n```\n值得注意的是：该函数的返回值不一定与系统中可用的处理器或内核的实际数量相匹配，系统可以为每个处理单元支持多个线程，或限制对程序的资源访问。\n\n### 访问当前线程\n\n　　std::this_thread 命名空间定义了几个访问当前线程的函数，你可以在线程函数中直接调用这些函数来实现一些功能。\n\n+ get_id\n`thread::id get_id() noexcept;`\n获取当先线程ID\n+ yield\n`void yield() noexcept;`\n阻塞当先线程的执行\n+ sleep_for\n`template <class Rep, class Period>`\n`void sleep_for (const chrono::duration<Rep,Period>& rel_time);`\n阻塞当前线程的执行一段时间\n\n```cpp\n// dev09.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nbool ready = false;\n\nvoid SetReady() {\n  // 等待 5 秒钟后设置全局变量 ready 的值为 true\n  std::this_thread::sleep_for(std::chrono::seconds(5));\n  std::cout << \"Display 函数即将继续执行\" << std::endl;\n  ready = true;\n}\n\nvoid Display() {\n  // 阻塞当前线程的执行，直到SetReady 函数设置\n  // 全局变量 ready 的值为 true 的时候才继续执行\n  while (!ready) {\n    std::this_thread::yield();\n  }\n  std::cout << \"线程ID: \" << std::this_thread::get_id() << std::endl;\n}\n\n\nint main () {\n  std::thread trd1(SetReady);\n  std::thread trd2(Display);\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nDisplay 函数即将继续执行\n线程ID: 140362842375936\n```\n\n+ sleep_until\n`template <class Clock, class Duration>`\n`void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);`\n阻塞当前线程的执行直到某个时间\n\n```cpp\n// dev10.cc\n// this_thread::sleep_for example\n\n#include <iostream>\n#include <iomanip>　　// std::put_time\n#include <thread>\n#include <chrono>\n#include <ctime>　// std::time_t, std::tm, std::localtime, std::mktime\n\nint main() {\n  using std::chrono::system_clock;\n  std::time_t tt = system_clock::to_time_t(system_clock::now());\n\n  struct std::tm * ptm = std::localtime(&tt);\n  std::cout << \"Current time: \" << std::put_time(ptm,\"%X\") << '\\n';\n\n  std::cout << \"Waiting for the next minute to begin...\\n\";\n  ++ptm->tm_min; ptm->tm_sec=0;\n  std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));\n\n  std::cout << std::put_time(ptm,\"%X\") << \" reached!\\n\";\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nCurrent time: 22:08:36\nWaiting for the next minute to begin...\n22:09:00 reached!\n```\n上面是摘自CPP官网的一段程序，主函数内生成一个关于系统时间的结构体，输出当前时间后使结构体内的分钟数自增1，之后调动 sleep_until 函数阻塞当前线程的执行直到下一分钟的到来。\n\n\n以上是对C++标准线程库的简单介绍，此文章内的全部代码可在下面的链接中找到：[https://github.com/zsimline/sweetea/tree/master/code/archives-667](https://github.com/zsimline/sweetea/tree/master/code/archives-667)\n\n参考资料：\n[1] CPP官网 [http://www.cplusplus.com/reference/thread/](http://www.cplusplus.com/reference/thread/)\n","tags":["C++"],"categories":["编程语言"]}]