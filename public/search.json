[{"title":"C++ 标准线程库","url":"/archives/1/","content":"\n　　C++11 引入了对多线程语言级别的支持，<thread> 库是C++的标准线程库，它定义了与编写多线程程序相关的类。 相比于传统的POSIX线程标准，<thread> 库更符合C++的编程风格。\n\n　　<thread> 库是跨平台的，这意味着你可以在任意平台上不经修改直接编译同一段多线程代码（前提是你没有在这段代码中调用其它系统相关的API）\n\n### 创建一个线程\n\nstd::thread 类用来创建一个线程\n\n```cpp\n// dev01.cc\n#include <iostream>\n#include <thread>  // 引入线程库头文件\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n\n  // 等待线程 trd 结束\n  trd.join();\n\n  return 0;\n}\n```\n```shell\n编译dev01.cc （需要动态链接pthread库）\ng++ -o dev dev.cc -lpthread && ./dev\n输出：index 的值为 1\n```\n　　std::thread 的初始化构造函数原型为`template <class Fn, class... Args>`, 构造函数的第一个参数为线程要执行的函数，后面是要传递给线程函数的实参。**值得注意的是，线程在thread类实例化之后就开始执行了，不需要显式的调用任何启动线程的函数。**\n\n　　线程启动后，需要在主线程内调用线程对象的 join 函数。join 函数用于阻塞主线程的执行，当新创建的线程执行完成后，主线程继续执行。一个进程内的所有线程共享某些资源，若不调用线程对象的join 函数，一旦主线程执行结束，操作系统将回收这些资源，新创建的线程得不到这些应有的资源就会终止执行并抛出错误。\n\n【拷贝构造函数】\n std::thread 类不支持拷贝构造 `thread (const thread&) = delete;`\n\n【移动构造函数】\nstd::thread 类支持移动构造函数 `thread (thread&& x) noexcept;`\n```cpp\n// dev02.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n  // 移动动构造一个线程对象\n  // 该操作不会以任何方式影响被移动线程的执行\n  std::thread trd1(std::move(trd));\n\n  // 此时trd对象不再代表任何执行线程\n  // trd.join();\n  trd1.join();\n\n  return 0;\n}\n```\n【赋值操作符】\n 可以使用赋值操作符移动赋值线程对象`thread& operator= (thread&& rhs) noexcept;`\n 不可以使赋值操作符拷贝赋值线程对象`thread& operator= (const thread&) = delete;`\n```cpp\n// dev03.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 创建线程对象数组\n  // 调用类的默认构造函数\n  std::thread trds[3];\n\n  // 使用赋值操作符移动赋值\n  // 该操作不会以任何方式影响被移动线程的执行\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  // 等待线程结束\n  for(int i = 0; i < 3; i++)\n    trds[i].join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n我是线程 2\n我是线程 3\n我是线程 1\n```\n可以看到，线程的执行顺序是不确定的，这取决于操作系统如何调度线程的执行。\n而且，输出也并不总是这样顺眼，比如下面的输出：\n```shell\n我是线程 我是线程 21我是线程 3\n```\nDisplay 函数中的输出语句是可中断的，当某个线程输出 “我是线程 ” 后，它完全有可能被操作系统挂起，等待一段时间后系统再次启动这个线程，输出剩余的内容。\n\n### 获取线程ID\n\n每个线程都有一个唯一标识，通过调用线程对象的 get_id 函数可以得到这个唯一标识。\n\n```cpp\n// dev04.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  std::thread trds[3];\n\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  for(int i = 0; i < 3; i++) {\n    // 线程ID 的类型为 std::thread::id\n    std::thread::id tid = trds[i].get_id();\n    std::cout << \"线程\" << i + 1 << \" \" << tid << std::endl;\n    trds[i].join();\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程1 140121399854848\n线程2 140121391462144\n线程3 140121383069440\n```\n\n### 检测线程可连接性\n\n通过调用线程对象的 joinable 函数可以检测线程对象是否是可连接的。\n如果线程对象表示执行线程，则该对象是可连接的。\n在以下任何情况下，线程对象均不可连接：\n1.  线程对象是由默认构造函数生成的\n2. 线程对象已经被移动（通过移动构造函数或赋值操作符）\n3. 已经调用过线程对象的 join 或 detach 函数\n\n```cpp\n// dev05.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 默认构造 trd1\n  std::thread trd1;\n  // 正常构造 trd2\n  std::thread trd2(Display, 1);\n  // 移动构造 trd3\n  std::thread trd3(std::move(trd2));\n\n  if(trd1.joinable()) {\n    std::cout << \"线程对象trd1可连接\" << std::endl;\n    trd1.join();\n  } else {\n    std::cout << \"线程对象trd1不可连接，它是默认构造的\" << std::endl;\n  }\n  \n  if(trd2.joinable()) {\n    std::cout << \"线程对象trd2可连接\" << std::endl;\n    trd2.join();\n  } else {\n    std::cout << \"线程对象trd2不可连接，它已经被移动了\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3不可连接\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3现在不可连接了\" << std::endl;\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程对象trd1不可连接，它是默认构造的\n线程对象trd2不可连接，它已经被移动了\n线程对象trd3可连接\n线程对象trd3现在不可连接了\n```\n\n### 分离线程\n\n调用线程对象的detach函数可以使新创建的线程与主线程分离，与join函数不同的是，detach函数不会阻塞主线程的执行，若主线程早于新线程执行完毕，新线程将终止执行，不会抛出任何错误。\n\n```cpp\n// dev06.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nvoid DelayThread(int s) {\n  // sleep_for函数使线程睡眠s秒\n  std::this_thread::sleep_for(std::chrono::seconds(s));\n  std::cout << s << \"秒过去了\" << std::endl;\n}\n\nint main() {\n  std::thread trd1(DelayThread, 2);\n  std::thread trd2(DelayThread, 8);\n\n  // 分离线程\n  trd1.detach();\n  trd2.detach();\n\n  // 主线程睡眠5s\n  DelayThread(5);\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n2秒过去了\n5秒过去了\n```\n\n### 交换线程\n\n通过调用线程对象的swap函数可以交换两个线程\n\n```cpp\n// dev07.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  // ...\n}\n\nint main() {\n  std::thread trd1(Display, 2);\n  std::thread trd2(Display, 8);\n\n  std::cout << \"交换前：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  // 交换两个线程\n  trd1.swap(trd2);\n  // 同样可以调用非成员函数交换两个线程\n  // swap(trd1, trd2);\n\n  std::cout << \"交换后：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n交换前：\ntrd1 ID: 140593231992576\ntrd2 ID: 140593223599872\n交换后：\ntrd1 ID: 140593223599872\ntrd2 ID: 140593231992576\n```\n\n### 获取硬件并发数量\n\n有时我们想知道处理器支持的硬件并发数量，可以调用线程类的静态函数 hardware_concurrency 来获取这个值，该函数返回值是一个无符号整数。\n\n```cpp\n// dev08.cc\n#include <iostream>\n#include <thread>\n\nint main() {\n  std::cout << std::thread::hardware_concurrency();\n  return 0;\n}\n```\n```shell\n编译上面的程序输出（在我的四核心处理器上）\n4\n编译上面的程序输出（在我的单核心处理器上）\n1\n```\n值得注意的是：该函数的返回值不一定与系统中可用的处理器或内核的实际数量相匹配，系统可以为每个处理单元支持多个线程，或限制对程序的资源访问。\n\n### 访问当前线程\n\n　　std::this_thread 命名空间定义了几个访问当前线程的函数，你可以在线程函数中直接调用这些函数来实现一些功能。\n\n+ get_id\n`thread::id get_id() noexcept;`\n获取当先线程ID\n+ yield\n`void yield() noexcept;`\n阻塞当先线程的执行\n+ sleep_for\n`template <class Rep, class Period>`\n`void sleep_for (const chrono::duration<Rep,Period>& rel_time);`\n阻塞当前线程的执行一段时间\n\n```cpp\n// dev09.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nbool ready = false;\n\nvoid SetReady() {\n  // 等待 5 秒钟后设置全局变量 ready 的值为 true\n  std::this_thread::sleep_for(std::chrono::seconds(5));\n  std::cout << \"Display 函数即将继续执行\" << std::endl;\n  ready = true;\n}\n\nvoid Display() {\n  // 阻塞当前线程的执行，直到SetReady 函数设置\n  // 全局变量 ready 的值为 true 的时候才继续执行\n  while (!ready) {\n    std::this_thread::yield();\n  }\n  std::cout << \"线程ID: \" << std::this_thread::get_id() << std::endl;\n}\n\n\nint main () {\n  std::thread trd1(SetReady);\n  std::thread trd2(Display);\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nDisplay 函数即将继续执行\n线程ID: 140362842375936\n```\n\n+ sleep_until\n`template <class Clock, class Duration>`\n`void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);`\n阻塞当前线程的执行直到某个时间\n\n```cpp\n// dev10.cc\n// this_thread::sleep_for example\n\n#include <iostream>\n#include <iomanip>　　// std::put_time\n#include <thread>\n#include <chrono>\n#include <ctime>　// std::time_t, std::tm, std::localtime, std::mktime\n\nint main() {\n  using std::chrono::system_clock;\n  std::time_t tt = system_clock::to_time_t(system_clock::now());\n\n  struct std::tm * ptm = std::localtime(&tt);\n  std::cout << \"Current time: \" << std::put_time(ptm,\"%X\") << '\\n';\n\n  std::cout << \"Waiting for the next minute to begin...\\n\";\n  ++ptm->tm_min; ptm->tm_sec=0;\n  std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));\n\n  std::cout << std::put_time(ptm,\"%X\") << \" reached!\\n\";\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nCurrent time: 22:08:36\nWaiting for the next minute to begin...\n22:09:00 reached!\n```\n上面是摘自CPP官网的一段程序，主函数内生成一个关于系统时间的结构体，输出当前时间后使结构体内的分钟数自增1，之后调动 sleep_until 函数阻塞当前线程的执行直到下一分钟的到来。\n\n\n以上是对C++标准线程库的简单介绍，此文章内的全部代码可在下面的链接中找到：[https://github.com/zsimline/sweetea/tree/master/code/archives-667](https://github.com/zsimline/sweetea/tree/master/code/archives-667)\n\n参考资料：\n[1] CPP官网 [http://www.cplusplus.com/reference/thread/](http://www.cplusplus.com/reference/thread/)\n","tags":["C++"],"categories":["编程语言"]}]