[{"title":"看懂了《让子弹飞》就理解了毛泽东和文革(转载)","url":"/archives/3/","content":"\n　　遍观姜文的作品，无论是如《鬼子来了》鞭辟入里的分析国民性格，还是反映“火红”年代所特有的青春期的骚动——《阳光灿烂的日子》，抑或是满篇充满政治隐喻的《太阳照常升起》，他的每部作品都与中国近现代史分不开。不论你持何种态度，不可否认对于20世纪的中国——影响最大的人物无疑是毛泽东了，姜文的作品显然也是绕不开毛泽东的，姜文曾多次说过他一生最崇拜以及最想演绎的角色就是毛泽东，“我演的毛泽东可能是通不过的。我觉得他可以把几万人带着迁徙，又没有补助费，像摩西出埃及一样。这种东西是精神上的，但他也很矛盾，很有悲剧性......我很幸运曾经跟他（毛）生活过一段。他是中国这几千年来能够冒出头儿来的这么三、五人中的其中一个。他跟旁边的人没法比，什么蒋介石，个儿太矬了......现在太多的恩怨，对他，会扭曲了他的精神。”\n\n　　找准了全片思想落脚点，如果对中国近代史稍有常识，就可读懂片中很多怪异场景的象征意义：鹅城：象征“五四”之前的中国，在片中多次出现的“鹅”显然象征着受精英阶层愚弄摆布数千年的劳苦百姓，它的身上有很多中国劳动人民的特质——自私、麻木、愚昧最主要的是一盘散沙...马拉火车：火车是工业时代动力的象征，马匹是农业社会动力的象征，此处显然暗讽某国的精英阶层外表上虽然接受了西方工业文明，但骨子里的价值观、政治形态还是封建农业社会的那一套...上海、浦东：“老上海”是上世纪二三十年代民国的缩影，也是权贵资本家的乐园，而“浦东”是邓爷爷改革开放下才有的产物，片尾张麻子的兄弟们坐着片头马邦德的“马拉火车”去了上海，尤其那句“浦东就是上海，上海就是浦东”露骨之极，其暗喻不言而喻...\n\n　　张麻子：一辈子致力于建立一个人人平等、社会公平的新世界的革命者（他来鹅城就为三件事“公平、公平还是他妈的的公平”）。推翻现有的反动阶层只是“万里长征的第一步”，对旧中国维护精英阶层的“道统观”的全面反叛以此建立一个没有剥削、没有压迫的新社会，才是张麻子的最大理想。在精英眼里一脸麻子的“张麻子”不但脸上没有麻子，而且浩然正气的他还有个非常“精英化”的名字——张牧之，牧之、润之，都是“泽披万民”之意，结合姜文演绎的张麻子的一生，显然张麻子就是姜文一直想演绎的毛泽东！\n\n　　张麻子的兄弟：和毛泽东打天下的兄弟们——很久以前和黄四郎一起为“辛亥革命”出过力，但革命成功后因为“惹不起”城里的官老爷们跟着毛上了山、当了匪（因为所代表阶层利益不同、国共分家），此后在毛的带领下经历千辛万苦推翻了“国民党反动派”，和毛一道准备建立一个没有剥削、没有压迫的公平社会，可惜在毛死后兄弟们却背叛了当初的誓言，坐着片头出现的马邦德的“马拉火车”去了“浦东”，从此中国又走了民国时代“权贵资本主义”的老路...\n\n　　六子：以毛岸英为代表的单纯的左派知识分子——众所周知，毛泽东的长子毛岸英在朝鲜战争中的阵亡是毛失去的第六位亲人（墓碑上“六”的手势也暗示这一点），而且在片中张麻子和六子私下以“父子”相称，但在公众面前又是“兄弟”，很符合现实中的角色的定位——当年毛泽东和毛岸英在人伦面前是父子，在志向方面又是同志！毛岸英和很多如陈独秀、瞿秋白之类的知识分子一样，在中国积淀了几千年的政治厚黑学面前幼稚的跟婴孩一般，所以片中的六子为了一份不起眼凉粉被反动势力轻而易举“玩死了”，而且死后完全得不到人民大众的尊重（毛岸英也是如此）！同时，剧中张麻子也对这个群体给予很大期望——让他出国留学学习西方先进的自然科学、感受西方如莫扎特音乐般的人文教育，远离中国几千年无比黑暗的政治。很多人暗传毛送其长子去朝鲜是为了“镀金”，回来好接班，谁知道为了一碗“蛋炒饭”送了命——其实这些人口中的“蛋炒饭”何尝不是六子肚子里那碗“凉粉”呢？！汤师爷的所谓“杀人诛心”就是如此吧！\n\n　　马邦徳及其夫人：一个为钱（葛优扮演的财迷心窍师爷）、一个为权（只要能做“县长夫人”不在乎县长是谁的妓女），他夫妻俩基本就是中国自古以来绝大多数知识分子的典型代表、现在活跃在各个领域善于忽悠大众的“专家”，利用掌握先进知识的优越性，长期和官僚阶层媾和，采取各种高超手段愚昧民众以便“合法化”的去搜刮“穷鬼”的钱财，片中的“假麻子”就是长期搜刮民财常用的道具之一...\n\n　　黄四郎：中国历来反动势力的代表，是集“王权、绅权、族权”为一身的封建势力，比如蒋——从片中可知：他出生豪门、去日本留过学，曾经为辛亥革命做出很大贡献，是千千万万“精英阶层”的代表者，推翻满清后黄四郎没有为广大人民的利益去继续革命，进城后迅速蜕变为骑在人民头上作威作福的“大老爷”（这些经历都与蒋极其相似），而且还是“铁打的老爷”，汤师爷之流仅仅是“流水的县长”，利用自身强大的武装政权和绝对的官僚权威经营着南中国全部的鸦片生意并且还贩卖人口去USA赚“dollar”，成了政治大老板刘都统“三条腿”中最粗的一条（“三条腿”暗指“三座大山”——封建主义、官僚主义、帝国主义）\n\n　　黄四郎的替身：暗指中国所特有“官僚主义权威”——无论是满清皇帝还是蒋政权，仅仅是官僚主义的替身罢了，近代的中国民众一次次的用“无量头颅无量血”换来的“共和”自以为是成功了，实质上却是赶下了一个旧的“官老爷”又迎来一个新的“官老爷”，民众的社会地位、政治地位仍没有实质改变，每次改朝换代死去的仅仅是“替身”罢了，“官僚主义”依然在社会现实以及传统文化中长期存在，这显然不仅仅是所谓西方先进政治体制就能完全解决的...\n\n　　有人说“最了解中国人的是鲁迅，最了解中国的是毛泽东”，张麻子可谓谙熟上层精英阶层和底层劳苦大众的活动心理，在底层人民眼里统治阶层永远都是那么强大、尤其黄府高耸铁门后的神秘感让人不寒而栗，但张麻子很清楚其实在团结起来的人民群众面前，再强大的反动阶层仅仅是“纸老虎”罢了，了解底层民众心里的张麻子用黄四郎“替身”的脑袋欺骗了人民大众，他表面上砍下的仅仅是一个替身的脑袋，但对民众来说却是摧毁了整个反动阶层的“官僚主义威权”，黄四郎让民众惧怕的不是杀人不眨眼的武举人、不是看似高耸的大铁门，而是劳苦大众长期以来对精英阶层顶礼膜拜的奴性罢了，鲁迅笔下反映的旧中国就道出了这一点，这就是中国实行科举制后长期存在于中国、并成为中国发展的社会毒瘤——“官僚主义权威”，可怜的黄四郎“替身”在群众的欢呼中被张麻子砍下了脑袋，同样也砍下了黄四郎平时鱼肉百姓、作威作福的“权威”，此时的鹅城百姓再无顾虑了，铁门后藏着的仅仅是一个纸老虎罢了！\n\n　　在攻下黄府前，张麻子在象征着反动势力权威的大门上打了一个大大的“感叹号”，其用意是表达一个旧时代将要结束了；而让自己兄弟打下了一个“问号”，显然张麻子对自己兄弟们在攻下黄府后会不会蜕变成下一个“黄四郎”是存在很大疑问的，片尾可以看出张麻子的这种疑问显然不是多余的……\n\n　　攻下黄府后，革命似乎成功了，民众拿回了属于自己的财富，而张麻子对财富、美色似乎没有什么兴趣，甚至连身后那把“交椅”也可以让于别人，但黄四郎显然没有张麻子的精神境界，他认为张麻子要么为了取得如他那般的权势地位、要么是为了他黄家五代人搜刮来的财富，而他却告诉黄四郎说：“你跟钱都不重要！没有你，对我很重要！”原来，张麻子是要消灭一切剥削人、压迫人的社会制度啊——这正是毛 建立新中国后所谓的“这仅仅是万里长征的第一步”的背后深意，他要摧毁的不是蒋介石的反动政权，他还要建立一个人人平等、社会公平的新世界，打破中国自古改朝换代、“打江山、坐江山”的历史周期律，这样远大的抱负显然是很多底层民众包括当是很多中共高层是无法理解的，这也是为什么很多民众尤其老帅们很自然的认为“三反五反”、“反右派”甚至“文革”等一系列打击整个“官僚精英阶层”的群众性政治运动，是毛泽东为了自身争权夺利的需要——其实这种推测根本不值一驳，叶剑英承认在长征以后，毛在党内的地位根本无人能撼动了，何况建国后刘、邓等资历差一大截的小辈！\n\n　　本片的结尾很好的呼应了片头，张麻子的兄弟们坐着马邦德的“马拉火车”和花姐就准备去权贵资本家的乐园——上海，寻找新的生活了，此时新的革命者又走了旧的统治者的老路！\n\n　　片尾，攻打黄府时，张麻子曾在黄家大门上打的“问号”成为了现实——\n　　张麻子问众人：“不跟我回山里了？”\n　　兄弟们道：“你腿脚都不利落了，还回山里啊。”\n　　张又问花姐：“你不是要跟我当麻匪到处发钱吗？”\n　　花姐：“今天不是把钱全发光了吗，还有比这更过瘾的？”\n　　张不甘心有问到：“和我在一起不高心吗？”\n　　众人道：“高兴，但不轻松、不轻松……”\n\n　　张麻子的兄弟们在革命成功后，准备和麻子分道扬镳了，建国后，毛 的“亲密”战友们也是感同身受吧：经历了红军反围剿、万里长征、抗日战争、解放战争，跟着毛 打江山、创造历史当然是很刺激很高兴的了……但好不容易打败了蒋介石坐了江山，这时候正应该论功行赏、大块吃肉的时候，打江山不就为了坐江山嘛，不然兄弟们这么多年血风腥雨的革命为了啥啊？！但大哥却让我们再回到清苦的山里当“麻匪”、劫富济贫——再时时刻刻把群众利益放在心里、把为人民服务放在第一位，甚至要和老百姓“同吃、同住、同劳动”保持艰苦朴素的本色，办事情还得看群众脸色、弄不好还要遭群众批斗……这活的也太不轻松了（毛时代的干部就是这样的），还是搭上改革开放的春风去了上海快活啊！\n\n　　到了六十年代毛敏锐的察觉到，有些曾经在战场上出生入死的老革命开始特权享受，放松自己、膨胀了私欲，置人民的利益而不顾，党内特权思想、官僚主义盛行——正如毛所说的“一部分party员不想继续革命了，有些人后退了，反对革命了，为什么呢？作了大官了，要保护大官们的利益。他们有了好房子，有汽车，薪水高，还有服务员，比资本家还厉害”……难道革命了几十年牺牲那么多战友这么短时间官僚主义就“复辟”了？可是此时身边出生入死的战友们没有人再愿意继续革命了，这时他又想到了他为之奋斗一生的人民，从旧中国走过来的中国人民的整体国民素质是令人堪忧的，毛泽东深知中国人在思想上受到宋明伪儒家思想的毒害之深，深知中国的底层民众对自己的要求一直依然是鲁迅笔下的那群事不关己高、高挂起的心态，他觉得只有人民的思想觉悟实质提高了、人民接受了先进的平等理念，只有这样才能有效防止“官僚阶层”走向人民对立面甚至骑在人民头上作威作福，所以毛泽东接见群众时不断强调“要少一点奴性，多一点主人翁的自尊心.”——不然空有所谓“民主”制度的印度为何至今还不能摆脱奴隶社会种姓制度的桎酷？！\n\n　　在这种背景下，晚年的毛泽东决定孤注一掷，发动一场全民性的、自下而上的，以革新文化思想以及打击整个官僚精英阶层为初衷的“文化大革命”，熟读史书的毛泽东显然知道得罪掌握话语权的官僚阶层尤其知识分子，将来会在历史上留下怎样的“恶名”（“我就在二十世纪六十年代当了共产党的钟馗了。事物总是要走向反面的，吹得越高，跌得越重，我是准备跌得粉碎的。”），但我们从毛的诗词中可以明显感觉到他首先是一位理想主义至上的英雄，对于身后名是完全不在乎的，晚年的他又开始了生命里的“第二次长征”——只是这一次，他蓦然回首，再也看不到那支曾经追随他、为了民族的自由和光明而一往无前、浩浩荡荡的革命队伍——夕阳西下、漫漫征途中陪伴他的只有自己孤独的身影……\n\n　　毛死后，理想主义的红旗落地了，没有人再去追求什么所谓的“社会公平”，一切向钱看了，正如他预言的那般“老百姓要吃二遍苦、遭二茬罪” 的。正如张麻子所说“死人有时比活人有用”，权贵们一边把毛泽东作为“无害神像”挂在城楼上、企图透支毛泽东所创造的丰功伟绩所带给他们的历史合法性，一边大搞黑毛和私有化运动、利用工农阶层的血汗来充实自己的腰包，“扛着红旗反红旗”不也是黄四郎的手段吗——\n\n　　在红军革命根据地时期，“朱毛”红军被蒋介石宣传成“共产共妻”、杀人不眨眼的“土匪”；在当下的“盛世中国”，毛泽东被权贵、精英们诅咒其为“暴君”、“屠夫”甚至是“20世纪人类的三大恶魔之一”。精英们恨不能对其挫骨扬灰，说明在受过毛时代不断的全民性政治运动启蒙后的中国人民面前，他们的内心是极度恐慌的，必定鲁迅笔下的中国人在渐渐减少！自古以来，黄四郎们都是先大肆诋毁真革命者为“麻匪”，然后把自己伤天害理的全部罪责推到“张麻子”身上，再以“剿匪”之名搜刮民脂民膏，这才是真正的“杀人诛心”、用心何其险恶！\n\n　　这个在精英眼里满脸麻子的毛润之到底给中国带来了什么“灾难”呢:\n　　在他执政的短短的二十七年间，无论是在朝鲜战争、对印自卫反击、还是苏俄在边境陈兵百万，毛泽东从未向这些强敌屈服\n过，中国通过一系列对外战争、卓有成效的外交行动重新获得了世界的尊重和认可，尤其是毛泽东以众横捭阖的高超战略、超人的胆识斡旋于美苏两强之间，为中国赢得了巨大的政治外交红利，至今受益。\n\n　　在短短的二十七年间，在辽阔的中国大地上，一举消灭了为害千年的匪患，肃清了黑社会帮派势力和一切扰乱社会、残害人民的黑恶势力，社会秩序空前安定。毛时代的犯罪率是中国历史最低的。\n\n　　在短短的二十七年间，在辽阔的中国大地上，彻底扫除了自清末以来全民吸食鸦片的恶习，铲除了危害国民身体、国民精神健康的“陋习”——如童养媳、裹脚、纳妾、男尊女卑等等，民族精神面貌也随之焕然一新；千百年来摧残和迫害妇女的卖淫、嫖娼的社会污泥浊水，被荡涤无存，妓女被改造为自食其力的劳动者，并且给予其应有人格尊严，中国只有在毛时代才真正算彻底消灭了“黄赌毒”。\n\n　　在短短的二十七年间，在辽阔的中国大地上，文化教育事业快速发展，扫除大量文盲，大力普及基础教育，从49年以前全国80%以上的文盲率，到70年代中国大地上新的一代青少年普遍都受过几乎免费的初等教育，中国人从没有把知识的学习如此“草根化”过。\n\n　　在短短的二十七年间，在辽阔的中国大地上，医疗卫生事业快速发展，消灭或基本消灭了多种存在于广大农村的传染病，如鼠疫、霍乱、天花等。在国家物质极其匮乏的年代，依靠合作医疗、赤脚医生、农村三级卫生保健网这“三大法宝”， 为中国数亿农民提供了最基本的医疗服务，并赢得世界赞誉。在27年内中国人口平均寿命从35岁提高到65岁。\n\n　　最为可贵的是，以刚建国时期一个长期积贫积弱、饱受战乱的极端落后的农业国，毛带领中国人民节衣缩食、自力更生在短短27年的时间里，建立成拥有完整轻重工业体系的世界第六大工业国，甚至还在航天核武电子等方面走在了世界前列，走完了西方主要老牌工业国100年才能完成的国家“工业化浪潮”，没有这些辉煌的成就奠基——“伟大”的总设计师用什么去改革开放呢？\n\n　　郁达夫曾说：“没有伟大人物出现的民族，是世界上最可怜的生物群体；有了伟大的人物，而不知拥护、爱戴、崇仰的国家，是没有希望的奴隶之邦。”\n\n　　就是这样一个彻底扭转中国几百年衰败国运、有“再造中华”之功并且享有世界普遍赞誉的伟人，在精英统治者眼中确实满脸麻子、奇丑无比，而且还是“悍匪”（如今暴君、屠夫纷至沓来），因为毛泽东彻底扯下了数千年来官僚阶层愚民术的最后一块遮羞布——群众在打到“官僚权威”、“学术权威”口号下，通过一系列政治运动让官僚和文人彻底丢尽了“脸面”，摧毁了官僚主义在人民群众中积攒了数千年的“权威”——正如毛所说的，“五帝三皇神圣事，骗了无涯过客”。\n\n　　张麻子为民做了主，民众下跪高呼“青天大老爷”，可张麻子鸣枪警醒大家：不能跪，早就没皇帝老子了，哪来的青天大老爷——毛设想的国人正如他诗中说道“春风杨柳万千条,六亿神州尽舜尧”，每个中国人都能有人格尊严、有独立精神的活着……\n\n　　毛泽东的晚年注定是孤独、凄凉的，正如剧中的结尾：昔日的战友尽数背叛了当初“上山”当“土匪”时的誓言，拥着花姐一路欢笑去了上海开始了“新”的生活；而暂时过上安逸生活的鹅城百姓又把“革命”高高挂了起来，并且又乐于“青天大老爷”为自己做主了；只有他仍不服输，和来鹅城前一样——骑着白马、一身戎装落寞的策马奔腾在夕阳中，他要永葆“山匪”的本色。\n\n　　正如尼克松评价道：“无论人们对毛有怎样的看法，谁也否认不了他是一位战斗到最后一息的战士。”，此时想必姜文也明白，唯有片尾李叔同的那首《送别》才能表达出毛泽东此时孤独落寞的心境：\n\n　　长亭外，古道边，芳草碧连天。晚风拂柳笛声残，夕阳山外山。天之涯，地之角，知交半零落。一壶浊酒尽余欢，今宵别梦寒……\n","tags":["那年夏夜"],"categories":["转载"]},{"title":"解决Debina系统自动更新软件包的问题","url":"/archives/2/","content":"\n　　不知从何时开始，我的电脑每天开机连接上网络之后，不断的在下载数据，状态栏显示网速达到每秒1到2兆。开始我还不太在意，不过后来由于带宽全部被这种莫名其奥妙的下载占据了，我连网页都无否正常浏览了，所以我决定解决掉这个问题。下面记录一下解决这个问题的过程。\n\n　　首先我利用一款名为`nethogs`的实时网速监控程序查看是哪个进程在占据带宽，发现占据带宽的正是系统的APT包管理工具，我想肯定是系统在执行自动更新。杀掉这个进程后，我便去Google了一下如何关闭APT包管理工具的的自动更新。网上人们提供的解决方案大都一致：修改APT的配置文件。\n\nAPT关于自动更新的配置文件位于\"/etc/apt/apt.conf.d/20auto-upgrades\", 将其中的\n```shell\nAPT::Periodic::Update-Package-Lists \"1\";\nAPT::Periodic::Unattended-Upgrade \"1\";\n```\n更改为\n```shell\nAPT::Periodic::Update-Package-Lists \"0\";\nAPT::Periodic::Unattended-Upgrade \"0\";\n```\n其中\n- APT::Periodic::Update-Package-Lists; 每一天自动运行一次 apt-get update，1 表示启用，0 表示禁用。\n- APT::Periodic::Unattended-Upgrade; 每一天运行一次 unattended-upgrade 安全升级脚本，1 表示启用，0 表示禁用。\n  \n　　然而，并无卵用，第二天开机后APT又执行自动更新了，更奇怪的是杀掉APT进程不久之后它会再一次运行。这时我才意识到一件事情，APT是不会自动把自己调入内存运行的，一定是另有进程调用了它。打开进程管理器之后，查看 APT 进程的依赖关系，发现果然它有一个名为 `packagekit` 的父进程，我查了一下 `packagekit` 是一个旨在简化Linux发行版安装和更新软件的系统，它为不同的包管理工具提供了统一的前端，你可以在不同的Linux发行版中使用它来管理软件包。\n\n　　我的系统默认在开机时启动packgekit服务，查看 `packagekit` 的启动单元: \n`cat /lib/systemd/system/packagekit.service`\n```shell\n[Unit]\nDescription=PackageKit Daemon\n# PK does not know how to do anything on ostree-managed systems;\n# currently the design is to have dedicated daemons like\n# eos-updater and rpm-ostree, and gnome-software talks to those.\nConditionPathExists=!/run/ostree-booted\n\n[Service]\nType=dbus\nBusName=org.freedesktop.PackageKit\nUser=root\nExecStart=/usr/lib/packagekit/packagekitd\n```\n*系统每次开机时都会启动这个单元，执行 `/usr/lib/packagekit/packagekitd` 命令，而 `packagekit` 又将在运行期间调起APT下载需要更新的软件包。*\n\n　　知道了这些问题自然也就解决了，禁用此服务: `systemctl disable packagekit.service`.\n　　或者干脆删除 `/lib/systemd/system/` 目录下的 `packagekit.service` (当然你也可以把这个文件移动到别的地方去，以后用到时再放回来)\n\n　　在那之后，系统便再也没有执行过自动更新了。\n　　\n[附]\n>[nethohs](https://github.com/raboof/nethogs)是一个能按进程实时监控网络的命令行工具，它可以动态的展示某一时刻正在进行通信的进程的网络流量信息。\n\n在 Debian/Ubuntu 下，使用`apt-get install nethogs` 安装它。\n或编译安装:\n```shell\nwget -c https://github.com/raboof/nethogs/archive/v0.8.5.tar.gz\ntar xf v0.8.5.tar.gz \ncd ./nethogs-0.8.5/\nmake && make install\n```\n如果编译失败需要安装依赖库\n```\napt-get install libncurses5-dev libpcap-dev\n```\n\n使用\n\n```shell\nroot@zsimline$ nethogs\nNetHogs version 0.8.5-2+b1\nPID  USER    PROGRAM                   DEV  SENT      RECEIVED  \n2181 mxsyx  /usr/share/code/code       usb0 0.449   0.900 KB/sec\n1598 mxsyx  /usr/lib/chromium/chromium usb0 0.031   0.018 KB/sec\n?    root   unknown TCP                     0.000   0.000 KB/sec\n\n  TOTAL                                     0.480       0.917 KB/se\n```\n\n指定网卡\n```shell\nroot@zsimline$ nethogs wlan0 # 监听wlan0\nroot@zsimline$ nethogs -a    # 监听所有网卡\n```\n\n指定刷新频率 -d seconds (默认为1)\n```shell\nroot@zsimline$ nethogs -d 2\n```\n\n指定刷新次数 -c number (默认不限)\n```shell\nroot@zsimline$ nethogs -c 10\n```\n\n交互模式\n在进入 nethogs 之后，可以使用如下的交互命令:\n```shell\nq: 退出\ns: 按照发送流量排序\nr: 按照流量排序\nm: 修改网速单位 (KB, B, MB) and KB/s\n```","tags":["Linux"],"categories":["Linux"]},{"title":"C++ 标准线程库","url":"/archives/1/","content":"\n　　C++11 引入了对多线程语言级别的支持，<thread> 库是C++的标准线程库，它定义了与编写多线程程序相关的类。 相比于传统的POSIX线程标准，<thread> 库更符合C++的编程风格。\n\n　　<thread> 库是跨平台的，这意味着你可以在任意平台上不经修改直接编译同一段多线程代码（前提是你没有在这段代码中调用其它系统相关的API）\n\n### 创建一个线程\n\nstd::thread 类用来创建一个线程\n\n```cpp\n// dev01.cc\n#include <iostream>\n#include <thread>  // 引入线程库头文件\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n\n  // 等待线程 trd 结束\n  trd.join();\n\n  return 0;\n}\n```\n```shell\n编译dev01.cc （需要动态链接pthread库）\ng++ -o dev dev.cc -lpthread && ./dev\n输出：index 的值为 1\n```\n　　std::thread 的初始化构造函数原型为`template <class Fn, class... Args>`, 构造函数的第一个参数为线程要执行的函数，后面是要传递给线程函数的实参。**值得注意的是，线程在thread类实例化之后就开始执行了，不需要显式的调用任何启动线程的函数。**\n\n　　线程启动后，需要在主线程内调用线程对象的 join 函数。join 函数用于阻塞主线程的执行，当新创建的线程执行完成后，主线程继续执行。一个进程内的所有线程共享某些资源，若不调用线程对象的join 函数，一旦主线程执行结束，操作系统将回收这些资源，新创建的线程得不到这些应有的资源就会终止执行并抛出错误。\n\n【拷贝构造函数】\n std::thread 类不支持拷贝构造 `thread (const thread&) = delete;`\n\n【移动构造函数】\nstd::thread 类支持移动构造函数 `thread (thread&& x) noexcept;`\n```cpp\n// dev02.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"index 的值为!\" << index << std::endl;\n}\n\nint main() {\n  // 创建线程 trd, 传入参数 1\n  std::thread trd(Display, 1);\n  // 移动动构造一个线程对象\n  // 该操作不会以任何方式影响被移动线程的执行\n  std::thread trd1(std::move(trd));\n\n  // 此时trd对象不再代表任何执行线程\n  // trd.join();\n  trd1.join();\n\n  return 0;\n}\n```\n【赋值操作符】\n 可以使用赋值操作符移动赋值线程对象`thread& operator= (thread&& rhs) noexcept;`\n 不可以使赋值操作符拷贝赋值线程对象`thread& operator= (const thread&) = delete;`\n```cpp\n// dev03.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 创建线程对象数组\n  // 调用类的默认构造函数\n  std::thread trds[3];\n\n  // 使用赋值操作符移动赋值\n  // 该操作不会以任何方式影响被移动线程的执行\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  // 等待线程结束\n  for(int i = 0; i < 3; i++)\n    trds[i].join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n我是线程 2\n我是线程 3\n我是线程 1\n```\n可以看到，线程的执行顺序是不确定的，这取决于操作系统如何调度线程的执行。\n而且，输出也并不总是这样顺眼，比如下面的输出：\n```shell\n我是线程 我是线程 21我是线程 3\n```\nDisplay 函数中的输出语句是可中断的，当某个线程输出 “我是线程 ” 后，它完全有可能被操作系统挂起，等待一段时间后系统再次启动这个线程，输出剩余的内容。\n\n### 获取线程ID\n\n每个线程都有一个唯一标识，通过调用线程对象的 get_id 函数可以得到这个唯一标识。\n\n```cpp\n// dev04.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  std::thread trds[3];\n\n  for(int i = 0; i < 3; i++)\n    trds[i] = std::thread(Display, i + 1);\n\n  for(int i = 0; i < 3; i++) {\n    // 线程ID 的类型为 std::thread::id\n    std::thread::id tid = trds[i].get_id();\n    std::cout << \"线程\" << i + 1 << \" \" << tid << std::endl;\n    trds[i].join();\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程1 140121399854848\n线程2 140121391462144\n线程3 140121383069440\n```\n\n### 检测线程可连接性\n\n通过调用线程对象的 joinable 函数可以检测线程对象是否是可连接的。\n如果线程对象表示执行线程，则该对象是可连接的。\n在以下任何情况下，线程对象均不可连接：\n1.  线程对象是由默认构造函数生成的\n2. 线程对象已经被移动（通过移动构造函数或赋值操作符）\n3. 已经调用过线程对象的 join 或 detach 函数\n\n```cpp\n// dev05.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  //std::cout << \"我是线程 \" << index << std::endl;\n}\n\nint main() {\n  // 默认构造 trd1\n  std::thread trd1;\n  // 正常构造 trd2\n  std::thread trd2(Display, 1);\n  // 移动构造 trd3\n  std::thread trd3(std::move(trd2));\n\n  if(trd1.joinable()) {\n    std::cout << \"线程对象trd1可连接\" << std::endl;\n    trd1.join();\n  } else {\n    std::cout << \"线程对象trd1不可连接，它是默认构造的\" << std::endl;\n  }\n  \n  if(trd2.joinable()) {\n    std::cout << \"线程对象trd2可连接\" << std::endl;\n    trd2.join();\n  } else {\n    std::cout << \"线程对象trd2不可连接，它已经被移动了\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3不可连接\" << std::endl;\n  }\n\n  if(trd3.joinable()) {\n    std::cout << \"线程对象trd3可连接\" << std::endl;\n    trd3.join();\n  } else {\n    std::cout << \"线程对象trd3现在不可连接了\" << std::endl;\n  }\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n线程对象trd1不可连接，它是默认构造的\n线程对象trd2不可连接，它已经被移动了\n线程对象trd3可连接\n线程对象trd3现在不可连接了\n```\n\n### 分离线程\n\n调用线程对象的detach函数可以使新创建的线程与主线程分离，与join函数不同的是，detach函数不会阻塞主线程的执行，若主线程早于新线程执行完毕，新线程将终止执行，不会抛出任何错误。\n\n```cpp\n// dev06.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nvoid DelayThread(int s) {\n  // sleep_for函数使线程睡眠s秒\n  std::this_thread::sleep_for(std::chrono::seconds(s));\n  std::cout << s << \"秒过去了\" << std::endl;\n}\n\nint main() {\n  std::thread trd1(DelayThread, 2);\n  std::thread trd2(DelayThread, 8);\n\n  // 分离线程\n  trd1.detach();\n  trd2.detach();\n\n  // 主线程睡眠5s\n  DelayThread(5);\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n2秒过去了\n5秒过去了\n```\n\n### 交换线程\n\n通过调用线程对象的swap函数可以交换两个线程\n\n```cpp\n// dev07.cc\n#include <iostream>\n#include <thread>\n\nvoid Display(int index) {\n  // ...\n}\n\nint main() {\n  std::thread trd1(Display, 2);\n  std::thread trd2(Display, 8);\n\n  std::cout << \"交换前：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  // 交换两个线程\n  trd1.swap(trd2);\n  // 同样可以调用非成员函数交换两个线程\n  // swap(trd1, trd2);\n\n  std::cout << \"交换后：\" << std::endl;\n  std::cout << \"trd1 ID: \" << trd1.get_id() << std::endl;\n  std::cout << \"trd2 ID: \" << trd2.get_id() << std::endl;\n\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\n交换前：\ntrd1 ID: 140593231992576\ntrd2 ID: 140593223599872\n交换后：\ntrd1 ID: 140593223599872\ntrd2 ID: 140593231992576\n```\n\n### 获取硬件并发数量\n\n有时我们想知道处理器支持的硬件并发数量，可以调用线程类的静态函数 hardware_concurrency 来获取这个值，该函数返回值是一个无符号整数。\n\n```cpp\n// dev08.cc\n#include <iostream>\n#include <thread>\n\nint main() {\n  std::cout << std::thread::hardware_concurrency();\n  return 0;\n}\n```\n```shell\n编译上面的程序输出（在我的四核心处理器上）\n4\n编译上面的程序输出（在我的单核心处理器上）\n1\n```\n值得注意的是：该函数的返回值不一定与系统中可用的处理器或内核的实际数量相匹配，系统可以为每个处理单元支持多个线程，或限制对程序的资源访问。\n\n### 访问当前线程\n\n　　std::this_thread 命名空间定义了几个访问当前线程的函数，你可以在线程函数中直接调用这些函数来实现一些功能。\n\n+ get_id\n`thread::id get_id() noexcept;`\n获取当先线程ID\n+ yield\n`void yield() noexcept;`\n阻塞当先线程的执行\n+ sleep_for\n`template <class Rep, class Period>`\n`void sleep_for (const chrono::duration<Rep,Period>& rel_time);`\n阻塞当前线程的执行一段时间\n\n```cpp\n// dev09.cc\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nbool ready = false;\n\nvoid SetReady() {\n  // 等待 5 秒钟后设置全局变量 ready 的值为 true\n  std::this_thread::sleep_for(std::chrono::seconds(5));\n  std::cout << \"Display 函数即将继续执行\" << std::endl;\n  ready = true;\n}\n\nvoid Display() {\n  // 阻塞当前线程的执行，直到SetReady 函数设置\n  // 全局变量 ready 的值为 true 的时候才继续执行\n  while (!ready) {\n    std::this_thread::yield();\n  }\n  std::cout << \"线程ID: \" << std::this_thread::get_id() << std::endl;\n}\n\n\nint main () {\n  std::thread trd1(SetReady);\n  std::thread trd2(Display);\n  trd1.join();\n  trd2.join();\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nDisplay 函数即将继续执行\n线程ID: 140362842375936\n```\n\n+ sleep_until\n`template <class Clock, class Duration>`\n`void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);`\n阻塞当前线程的执行直到某个时间\n\n```cpp\n// dev10.cc\n// this_thread::sleep_for example\n\n#include <iostream>\n#include <iomanip>　　// std::put_time\n#include <thread>\n#include <chrono>\n#include <ctime>　// std::time_t, std::tm, std::localtime, std::mktime\n\nint main() {\n  using std::chrono::system_clock;\n  std::time_t tt = system_clock::to_time_t(system_clock::now());\n\n  struct std::tm * ptm = std::localtime(&tt);\n  std::cout << \"Current time: \" << std::put_time(ptm,\"%X\") << '\\n';\n\n  std::cout << \"Waiting for the next minute to begin...\\n\";\n  ++ptm->tm_min; ptm->tm_sec=0;\n  std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));\n\n  std::cout << std::put_time(ptm,\"%X\") << \" reached!\\n\";\n\n  return 0;\n}\n```\n```shell\n编译上面的程序输出：\nCurrent time: 22:08:36\nWaiting for the next minute to begin...\n22:09:00 reached!\n```\n上面是摘自CPP官网的一段程序，主函数内生成一个关于系统时间的结构体，输出当前时间后使结构体内的分钟数自增1，之后调动 sleep_until 函数阻塞当前线程的执行直到下一分钟的到来。\n\n\n以上是对C++标准线程库的简单介绍，此文章内的全部代码可在下面的链接中找到：[https://github.com/zsimline/sweetea/tree/master/code/archives-667](https://github.com/zsimline/sweetea/tree/master/code/archives-667)\n\n参考资料：\n[1] CPP官网 [http://www.cplusplus.com/reference/thread/](http://www.cplusplus.com/reference/thread/)\n","tags":["C++"],"categories":["编程语言"]}]